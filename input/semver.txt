Hello, and welcome to Swashbuckling with Code, I'm Jimmy Cleveland, and today's video is going to be on the topic of semantic versioning, also known as semver.
There are many systems that use semantic versioning, such as Ruby since 2.1 and it's a standard for RubyGems if you're familiar with that, but in this video I'm going to be covering it under the lens of NPM.
But if you're not familiar with Node or NPM, I still think following along will be useful because the main concepts that I cover are all the same throughout all semantic versioning systems.
Now NPM actually has a quick introduction video to semantic versioning, and I'll link that in the notification description, so if you want to check that out, feel free.
What I'm trying to do is a little bit different.
I'm going to go into a little bit more depth, and hopefully you'll walk away with a really sound understanding of semantic versioning, and I'm going to be doing that in what I hope is a practical example by using two major packages in the NPM repository, Inquirer and Chalk.
Hopefully this will give you a real world example of encountering situations where you want to update your package and how you might troubleshoot that or how you go about doing that.
So with that out of the way, let's get into semantic versioning.
Now I have some timestamps at the bottom of this video in case you want to jump ahead to the actual code segment.
This first segment is going to be me talking about what semantic versioning is and why you should learn it and kind of why it came about.
Then I'm going to go into some actual code projects and we're going to show examples of installing different versions of packages, what all the different symbols and numbers mean and all that.
And that'll wrap up the second part of the video.
So a common question that comes up with semantic versioning is why?
The short answer of that is without some sort of specific versioning spec in place or a system that everyone complies to when they make packages that they're going to distribute and for people to install, there's just going to be chaos and unreliability.
Semantic versioning gives package maintainers and creators a way to communicate what is in each change that they put out.
Some high level examples of that are going to be, does this version update include a bug fix that I am safe to update to without changing my code at all, even if I don't even have the bug?
Does the new update have a feature that I may or may not use, but won't affect the existing features?
Or is it such a major change of the code base that previous users of the package are going to have to change their code, otherwise they're going to risk things breaking when they use it?
These are the major points that a semantic versioning system is trying to address.
Whenever you roll out a package, there's three numbers and no more, no less.
The numbers are major dot minor dot patch.
So a common example of that will be 7.2.0, in which seven is the major version, two is the minor version, and zero is the patch version.
If a new bug fix came out, the patch version is the first thing to go up because it's just a bug fix and it's just going to fix some previous existing bug that you don't have to do anything about.
You just install the package and it'll fix it for you.
So that would be 7.2.1 in this example.
Then maybe there's a new feature that you might want to access.
That would be 7.3.0, for example, for the next bump.
Even if it has multiple new features, it'll still be the next number up for the second position, which is the minor one.
Finally there's the major version, and that's called a breaking change when that updates.
So this is the case would be 8.0.0 if any breaking change would exist in the code base.
So sometimes a new feature comes along with a breaking change.
And so that's where you'd have to jump from 7.3.0 to 8.0.
Because even though you're putting out a new feature, it breaks the code.
So when you see a move from just a minor number, just to be clear, 7.2.0 for example, to 7.3.0, well that 2 to 3 in the middle position is saying this is a new feature for you, but it doesn't have any breaking changes that we know about.
You can opt into the feature if you want, but you don't have to change your existing code at all to run this package.
I really think that learning how semantic versioning works will make you a better coder if the concepts are foreign to you at all.
Because it helps you think about your code in a way that you can distribute it to users without breaking their functionality.
It really kind of opens up a new way of thinking if you're new to this concept.
Where you think, okay I shouldn't just change whatever I want to add a new feature or to fix a bug regardless if other people are going to use this.
I should really selectively think about when people use this, how's it going to affect their code?
If they do it in such a way that they can just install it and it fixes their bugs and they don't have to do anything at all, then I should probably opt for that path.
It's a sort of like least resistance here where you want to start with a bug fix.
If you have a minor, okay cool.
You have a new feature that you want to show them.
And then kind of as a last resort should you do a breaking change.
You want to try to keep those to a minimum as much as possible because they're scary for people that are updating packages.
One more quick point on this is that if you do have some new way of doing your code that normally would cause a breaking change, you can actually still make that a minor by including the old behavior and then putting a new way to handle the new feature such as a new value in an option config object or something like that.
Then you can flag that as deprecated which means that it's not favorable to use that because we're going to be removing it in the future but it won't break it right now.
And then you can slowly migrate users away from that old behavior so you can get rid of that part in your code base.
So you can kind of see how thinking in semantic versions really helps you write more robust, reliable, and communicative code.
To sum up all those points, semantic versioning promotes thinking about your users rather than yourself.
Now a downside to semantic versioning is that it doesn't tell you how much code has changed or even how much code you'll have to change if you're the consumer of the package updating it.
There are definitely those that have drawn criticism to semantic versioning because of that but regardless it's still a widely adopted system and I don't know of any better ones that are being used in mainstream products currently.
But I thought that you'd like to know that it's not new unanimous.
There are critiques about it of course as with anything in software engineering.
So the last point that I want to hit on before I jump into the code and show the practical examples is these special little characters that you might see.
One is the caret or sort of an upward chevron if you can call it that and the other one is a tilled character which is a little squiggly.
Whenever you see that the most common default is that caret character in the front of your number so you'd see the caret 7.2.0 for example.
What that's saying and this is the default in npm is that when you install that package if it ever updates for any reason whether it's through like some sort of npm update or you run npm install or you don't have a lock file or whatever there's various ways that this can happen it will never bump past that major version because that's a breaking change and so that could be dangerous to your code and that's why it's the default.
So that's why you'll see that there.
If you were to leave that off and you ever see a package installed with just 7.2.0 no character in front of it that's saying this exact version never update it it's only going to be this one.
Now the other one that you'll see which is a little less common is the tilled character and what that is saying is that we're going to be a little more restrictive instead of updating a patch or a minor we're only going to allow updates of patches or bug fixes.
So I don't even want new features maybe I don't want to risk it or whatever I only want bug fixes.
That's definitely not as common but you will see that from time to time.
There's a lot of other nuances of course to semantic versioning as with most things but I'm really trying to hit the major points so that you understand the big picture and so I think it's a good time to jump into the code and hammer that point home with some practical examples.
For this first example I'm going to walk through making a quick project setup just so you know everything that's going on but we're going to do it pretty quickly so don't worry.
So we're going to first do create a directory and I'm going to name it semver example we're going to cd into that example and then we're going to do is npm init dash y.
It's just to say yes to everything.
Now one thing that I want to do here is install this package called inquirer.
Now inquirer is a really popular package it is used to create CLI command prompts to where you can in the terminal give a user questions and they can answer it and then you can get feedback and act on that program.
It's a really really powerful tool and you're going to see it in action in just a moment.
It's just a brief introduction.
Now normally you would install a package by just typing the name and that's good right but what we're going to do is we're actually use the at symbol and pick a specific version in this case I'm going to pick 7.2.0 so that is major for the seven minor for the two and patch for the zero.
Now I'm going to have an example of each of these so don't worry about that as we walk through this just to reiterate that's what it is major minor patch.
That's the thing that you want to ingrain in your brain.
So I'm going to install that real quick and then I'll show you it in action.
Now if I jump over here to my browser I have npmjs opened up here and you can see that this is a very popular package 21 million and I've selected it for that reason because it's such a common package that it's a real world example that's commonly used and you'll be able to do this yourself and follow along and I've imagined for the foreseeable future that's not going to change.
So hopefully that makes it pretty practical.
Let's jump back over here and let's open our editor.
Now in this we're going to have a package json and the thing about that that's interesting is even though we installed 7.2.0 you'll notice that it did that but it put this little caret and what this is saying is that whenever you do an install or an update it will never go past the major version because that's breaking changes but it will go past the minor and patch.
So if you look at package lock json and this will be really similar to yarn lock we can actually do a quick search for this package we'll do inquirer and you'll notice that with inquirer here under node modules if you're using a older version of npm it might be a little bit different format here but this is pretty similar.
So it says we have 7.2.0 installed so that's the actual version installed.
I'll show an example where that's not the case but for now we'll just keep moving on with this example.
You'll notice that it also has these dependencies so it has its own dependencies and they'll have their own dependencies and that's how the whole thing works so it's snapshotting each of these versions and you'll notice that they're all using this really common default where it's saying hey I won't go above a major because that's a breaking change but I will auto update minors and patches.
So if the first time that you install this you can see this is an exact version actually because it doesn't have a little character the first time you install this let's say that Lodash it had a lower version of Lodash but there's a newer one out that is still four it'll actually update to the newer one.
So package locks are kind of their own beast and I can't really cover that in this video it's a little bit out of the scope of this if you really want me to I do have an older video that I'll link in the notification that kind of covers package lock a little bit but if you want me to recover it or refresh it and do some new stuff just let me know in the comments if you're really interested in that.
So going back to this, this is one way that we can look up our version, but we can also do a really cool command here where we can do npm ls and that will actually list out all of our packages that we've manually installed, not their dependencies unless you use a flag.
Let me show you that real quick.
If you do dash dash depth, you can do equals and you can pick the depth.
So in this case, with depth of one, we'll show all of the immediate dependencies.
And if we were to do depth of two, it kind of gets a little crazy and so on and so forth, dependencies of dependencies and all that.
So let's go back up to the root one.
Now, if you do npm ls, you can see that and it's going to list out the actual version that you have installed, not the one that you picked.
Okay, sometimes that's confusing to people.
And why it would differ is depending on if you use the care or the tilt, which we're going to get into.
But for now, you can also just really quick.
So you know, there's an alias npm list.
If that makes it a little bit easier.
You can also do this, though, you can do npm view, which is really interesting.
And if you pick a package, you can do inquirer.
And this is one that's like, let's say it's not even installed, I'll show you that it will list out a lot of interesting stuff about it.
So you'll notice that when we do this, it says inquire 812, that's typically going to be the most current version.
So we're all the way back on 720.
Right now, it'll give you some keywords.
And it will also like give you some information here.
I don't think I should go over that right now.
But the important part is that it will list out the dependencies, which is really useful.
And the lovely maintainers who keep this project going, of course, thank you to all of them.
And then finally, it'll have a tag.
And this is where at latest will come into play a little bit later on.
So keep that in mind for now.
So jumping back to our example, that's how you can view a package and kind of see what the latest version is and all that stuff.
What I'm going to do is go into here and our project and do index dot j s just to create a quick little entry point.
So to save some time here, I'm going to paste in some code that I've already done.
And I'm going to walk you through it really briefly.
But if you've never used inquire before, we're just going to import it here.
And of course, this is a require syntax and not import syntax, because I'm just trying to make it simple for this current version of node.
We you could do it the other way, if you want, we have an inquire, we have a prompt command that you're going to chain onto it.
And essentially, what that's going to do is prompt the user for something, you're going to pass it this like array of objects of all the things to prompt them in order.
And there's a different way to do it, but we're gonna stick to this one.
And then the highlights are that you have the type of prompt that's going to be displayed as you have the name of it, which you're just going to use to keep track of it, the message that you'll show to the user, which you'll see in a moment, and then the choices, which can be a few things, we're going to do an array of strings.
So I'm asking them to choose their character class.
And then I'm going to give them this list of options.
And then after that, I'm going to give them a checkbox version to choose exactly two proficiencies.
Okay.
And then finally, at the end, it's a promise.
So you can chain onto it, don't worry about this for now.
And you can log out the answers and you can catch an error.
Okay, if you don't quite follow all that, that's perfectly fine.
You'll see an example, I just thought you might want to know kind of a little bit about what's going on.
So what we'll do is we'll do node index dot j s to run the program.
And you'll see that the program has a nice little prompt for that little bit of code, which is really cool.
And we can kind of arrow down through this.
And what I want you to pay attention to is that it's looping through all the list.
And so this is pretty cool right off the bat.
Well, let me get into that in a moment.
Actually, let's just pick the options now.
So I picked Druid.
And then right now, I can pick, you know, one option and press enter.
And it'll wait a couple of seconds in the code.
That's what I've programmed.
And then it's going to say, please choose exactly two proficiencies.
And so I'll do sure I'll do two of them.
I'll just show you that if I do three, it'll still won't allow that.
There you go.
So go back to that takes a couple seconds, and then it prints it out.
It's a really, really simple program, you could do whatever you want from there.
But that's not the purpose of this video.
What is the purpose is semantic versioning.
So remember how I mentioned that that program loops, let's run it one more time and see that.
So the program loops through and if someone's not really familiar with this, it might be confusing, you might be going through and being like, wait, did that loop?
Did I already see this one?
Sometimes it's kind of nice in some programs to the list to just end.
So we've been wanting this for a while.
And then through a blog or a friend or however, you figure this out, we learned that inquire has a new feature, where you can pass a special little property that makes the loop the list not loop, that was hard to say.
Now, let me show you that in their docs real quick.
So if you go to inquire right now, this is the latest version, which is ahead of where we're at.
But if you type loop, you'll see that there is this loop option.
So this is current, but let's go back in time for just a moment here.
If you go over to the repository, and click this.
And what's cool about this is there is a releases section in GitHub.
And this is up to the maintainer to, you know, keep this updated with information or whatever.
But a lot of the big projects will have something like that.
So this is the current version, let's scroll down and go to the next a couple of times to go back to back in time to where we are, pretend that we're in current time.
And seven to was the latest.
Here we are at seven to oh, and then all of a sudden, let's go back one.
And there's a seven three, oh, out now remember, that's a minor, the three, and they have a new loop Boolean for list types.
This prevents the list from looping when reaching the top or bottom of the selection.
That sounds pretty interesting.
So let's upgrade to that.
So if we go to our terminal, I can do npm i inquirer.
And I could do at and then I'll say that example exactly.
So seven three, oh, we did seven to oh, before.
Another way that you could do it just so you know, is you could go into your package JSON.
And you could like manually change this to a specific version.
But I usually prefer to use the command line.
I think it just does a little bit better job.
That's up to you.
You can play around with however you like.
Sometimes the versions are a little bit finicky and how they work.
But once you mess around with them a little bit, you'll get the gist of it.
So I'm gonna install seven three.
Oh, and just so you know, as a quick little hint, remember how when I installed seven three, oh, it automatically did this little up carrot that says it'll upgrade to whatever version.
As long as it's not a breaking change, you can actually do dash dash save exact.
As a flag, and check this out, when I go back over to here, it did not put that.
So if you really want to stick to one version, I usually don't recommend that.
But there are times when you do want to do that, then that's how you would accomplish that through the command line.
Let's undo that.
Let's just do this.
If we do npm ls, just as kind of a habit, you could see that that's the version that was installed.
So now we can go back into our code.
And we can add this little flag here because we got a new feature.
And we'll say, list, no loop.
Nice.
False.
I'm gonna do the same on both.
False.
And then what we'll do now that we've done that is let's just try to run the program and see if it worked.
So if I press up, it doesn't go up, which is good before it would.
But now if I press down, oh, that's interesting, isn't it?
It gets to the very bottom.
But it still shows the rest of the list, which I guess is okay.
You know, it doesn't let them move on.
But I feel like it's still a little bit confusing, right?
So we'll say, all right, feature works as intended.
Let's check this next one out.
What happens here?
Oh, this one just like keeps looping.
So it didn't even work for the checkbox type.
Let's pick our to, you know, close our program.
So what's interesting about this is, whether this is real time or not, what's kind of going on here is they have implemented this, but they have a bug in it.
Okay.
And this is super common.
So if they have a bug, and they want to fix it, but it's going to fix an existing feature, but not create a new feature, what should they do?
What do you do?
should be the version?
Well, that's where a patch comes in, right?
If we go over here to the previous step, this is going, you know, ahead in the future, we have a 731 and a 732.
And you'll look at the 731.
For now, it says fix the loop false option in the list prompt.
Okay, so here's what we could do.
This is where I'll show you the patch only version of installing something which is kind of interesting.
We can go over to here and we can see that we've got a patch.
And we can see that this is the patch that's going to fix the loop.
So what I'll do is I'll go to the patch and I'll do a patch on the loop.
So I'll do a patch on the loop.
And I'll say, okay, I'm going to go to the patch.
And I'll say, okay, I need a patch on the loop.
And I'll say, okay, I need a patch on the loop.
And I'll go back and install this program once again, and just install this patch just to see.
Now we install the patch, and then we'll run the code again.
And we can't go up.
So that's still working fine.
But when we get to the bottom of the list, look, it doesn't show the rest of the stuff.
So that's a an effective patch, it actually fixed it like that.
And then if we come back to here, oh, no, it didn't actually work for this, you know, they only fixed it for the one thing, unfortunately.
Well, let's go back to that, because we did see that there was another patch after it.
And it says fix the loop false option in the checkbox prompt, which we just so happen to have that problem.
And so let's bump one more time.
And in fact, this time, I'm gonna do a tiny bit different just to show you a different way.
If you use this tilled little squiggly character here, and then you say, I'll even do 730.
What this is going to do, you'll see is after installed, if we do npm ls, notice that we said I want 730, but it did 733.
And if we look in our package JSON, you'll see that that little tilt characters there.
So this is a special little character, you won't see it too often.
But every now and then you will that means only update to the highest patch version, don't update to a minor.
So at this point, it's determined that of all the packages that exist right now in time for this, that are not above a minor of three and not above a major of seven, there is a 733 is the highest version.
You notice it doesn't list it here, but it does list it in the here.
That's the thing I mentioned, it's kind of confusing to people sometimes, because this is your target.
This is saying, this is what I want, roughly, I'm okay, if you give me any number here for this patch version.
And that's what we got was 733.
Okay, so let's run the program again.
Go down to the bottom.
Cool.
See, it starts at acrobatics.
Oh, look at that.
It actually fixed it.
Cool.
Boom, boom, boom.
Wait a couple seconds, which will matter in a moment.
And there you have it.
So that's an example of showing we did a minor bump.
And what we could conclude from that if they did their job publishing the package properly, you know, bugs slip in sometimes.
So that's how it goes.
But with a minor bump, it's just going to be a new feature.
So that's we did a minor bump so that we could get this access to this new property, right.
And then we had two patch bumps that we needed to do in order to fix these bug fixes.
If we go back to this just one more time.
And we go previous, there's going to be one more, you'll see 733 before 800.
Okay, so this is the highest patch and minor version that exists.
Okay.
Another way that you could do that without actually going to the repo, though, is you can do npm view.
And you can do shorthand for this, it's V.
And then you can do inquirer, oops, and you can do versions.
So view versions.
And what that will do is print out all the versions.
So in case you wanted to see what ones exist, you know, just through the command line, you can do that, which is pretty neat.
So 733 is our latest.
You can also do the same thing and do dash dash JSON.
Some people prefer this because it always prints out the full list.
And it's in this kind of single column list format.
But I usually do this since it's a little more truncated, it just depends.
Now how you actually discover these new features is sort of a Pandora's box to a degree, it really just depends.
You might be subscribing to some sort of service or blogs or Twitter or whatever it is that like, you know, kind of gives you some sort of notifications of new features or whatever.
You might just hear it.
Or what happens commonly is you'll do some sort of package bump for some reason.
And you'll notice that it bumped up a version and then you might want to go read about why did it do that?
You know, what's in the new version, I don't really have a better way to keep on top of packages.
So if anyone does have any suggestions, go ahead and show it in the comments and we'll be grateful.
But I just wanted to show you that like what it means the patch and the minor.
And now we're going to move on to a breaking change example.
So if we go into this code here, we'll notice that inquire eight doesn't give us a ton of information on what happened.
But it does say that it drops support for node 10.
Now this is a really common reason to be a breaking change.
All right.
So I'm going to show you an example real quick of upgrading to eight on an older node version to show that not working.
So right now I'm using NBM, you might not be able to follow along here.
If you're only installing one node version, you don't have a version manager, that's okay.
You can see it through here.
But if you wanted to follow along, probably easiest to use a version manager like NBM or N.
So right now I'm currently on 1415.
One, right.
Now what I'm going to do is NBM use, and I'm going to do 8.17.0 because I have that installed.
All right.
Now I'm going to have to reinstall these packages at this point.
And it should run fine if I were to run this again, because I haven't upgraded just yet.
Just to show that.
Okay.
So currently all my stuff is supported.
You notice that I don't get the syntax highlighting here, which is kind of interesting.
So I wonder if they added that in a newer node version.
Now, why someone might, you know, do this right here, which is drop support for a node version, because when new features come out in node, you know, sometimes you'll keep deprecated, which means you'll keep the functionality, but you'll have to add some extra code for like background support while you upgrade.
And eventually what deprecated means is that you're going to stop supporting that at some time in the future.
So if you ever see that deprecated message, that's what they're saying.
They're like this, I'm going to drop support for this at some point in the future.
So if you update your package, expect that you might lose that.
And you probably want to get ready for that sooner rather than later.
Now, because node 10 would have a bunch of new stuff from the old node version, they might want to just use that stuff natively.
And eventually, you know, everyone kind of needs to stay current.
So that's why they might do that.
Just a real quick summation.
So let's update to eight.
Okay, so npm i inquirer at eight.
Let's actually just do latest.
Okay, so you can see that tag.
So you can actually do at latest, and that will do if you remember, now that installed, if you do npm v, oops, npm v inquirer.
Why can't I type ever?
You'll see this dist tag latest.
This is a really common way to just install whatever they have flagged as the latest version.
So this will give us 8.1.2.
Okay, and if we do npm ls, it'll list them all out.
Oh, I wonder if an older version of Node, it doesn't actually truncate those.
That was kind of interesting.
Well, either way, let's try to run our program.
Node index.js.
And you'll notice that we immediately just get some sort of error when we try to do it.
Okay, looks like they're using this catch block here.
And it says unexpected token this brace.
So we probably didn't have that type of functionality, we can guess from an older version of Node.
So what we need to do is upgrade our node.
In my case, I can just switch to 1415.1.
Right?
I'll install once again.
And then I'll do node index.js.
And my program works just fine, right?
Now, what's cool about that is, did you see that little loader?
Wasn't that neat?
So this is kind of an interesting example.
I should have explained this a little bit beforehand.
But I think this showcase it fine.
showcases it fine.
So if I pick, you know, Druid, I want to be Druid.
And let's say, of course, as a Druid, I want to be proficient in animal handling, and acrobatics, why not.
So I'm going to pick these two options.
And look what happens when I press enter, you see that little loading spinner, we didn't used to have that feedback.
And so this is sort of an example of at some point, let's find that.
If you go back, now displays a loading spinner while asynchronously filtering over validating data.
Cool.
Cool.
So this is an example where you want to upgrade to a major version, because there's a new functionality, we really want that loading spinner.
That's awesome.
But it's a breaking change, right?
And so we would have to kind of figure out, all right, well, what is, you know, what's the breaking change here.
So the best way to do that is to look for where the actual major bump happened.
And in this case, it's going to be the first time after seven, since we're on seven something, we move that that first number up to eight.
And so that's where they're going to just list any breaking changes, if they're maintaining the package properly and documenting it.
Sometimes there'll be other ways that they document how to deal with a breaking change.
If it's a major version, it might be in a post of theirs, if you just search it up, might be in the readme, if it's brand new.
But a lot of times, if I don't find it really easily, this is where I'll look.
And again, that's if you go to just the plain old repository from NPM or whatever, there's a releases tab here on the right, it might be different in the future, but usually just look for releases.
And then you can go find that specific release.
So that's one example of a breaking change.
It's a really common example, where the node version updates, but really all you had to do was update your node, right?
node version.
Let me show you one more example of a breaking change that actually forces you to change your code.
Okay, so fast forward through time real quick.
And I've created a quick project here, just to speed things up.
That's very simple.
And it's using this package chalk, a lot of you will be familiar with it.
It's a console dot log printing solution that will color your logs with different awesome little colors.
Okay.
If you look at my package JSON, I only have that one installed.
And I'm starting at one one three, right.
So I'm going to show you this program.
But to briefly walk through it, I have a print method that I'm using.
And really all this program is doing is you can normally do chalk dot magenta to print out a magenta text, which we'll see in a moment.
And then I also have one that just prints out this like generic thing.
So let's say I'm like logging a bunch of stuff, or whatever it is.
And I want to be able to color things differently with chalk.
What this print thing does is it uses this chalk has color method to see if the text is colored.
And if it is, if it does have a color, it will just print it out the way that it is, else it'll make it green.
That's it.
So let's go back to the terminal here.
And in this project, you'll see that in the first example, I print out purple, magenta, and the second one I print out green.
And that's exactly what I expect when I look at the code here.
So I decided there was a color, keep the color.
Otherwise, if I didn't give you a color, make it green.
It's pointless, but it'll illustrate the point.
So now let's actually go and look at the chalk npm package.
Chalk.
We can go to this package, we'll go to the repository for this point, go to releases, they're already all the way up to 4.1.2.
So we're really behind at this point.
But releases, I clicked on 4.1.2, I actually need to click release, sorry, all of them.
This is a really awesome project.
They document it super well.
So you know, so this is I wanted to show this because not only the code version of a breaking change, but just the maintainers of this are awesome.
Okay, so what we'll actually do is we'll go back to one more, sorry, and we'll find two.
So here's a major change.
They have this awesome GIF and everything.
And this is the really awesome moment where chalk introduced true color support, which is really fantastic.
You'll see, I'll give you a quick little demo of it.
But the point of it is that one, we want this new feature, we want this like tons and tons of color range and all that type of stuff.
And I'll show you that in a moment.
But what they do is they list breaking changes here.
I love this.
And so with this breaking change, you can look through and it requires no JS4, so pretty common what we just experienced.
But also they removed chalk.hasColor.
And we were using that.
And that's really unfortunate for us, right?
So let's show you that breaking our code real quick.
So we're going to bump this up here, we're going to say npm i, I'm going to install chalk.
And but we're going to do that at 2.0.0, let's say, and we really could just, you know, do whatever range.
In fact, let me show you this, there's one more command that you want to know.
So you actually can use this little up carry Chevron here to say, how about go ahead and grab me anything as long as it's not above three for a major version when I install it.
Okay, and this isn't going to work for me, just so you can see, this is a common problem with ZSH and some other terminal shells, where what it's like thinking that it's some sort of matcher here.
So what we're going to do is we're going to escape that character.
If you ever had that problem, that's all you have to do.
And that'll work.
So now when we do npm ls, you'll notice that we didn't install to Oh, like we normally would have if we left that off, we'll actually install two for two.
So we're saying, Hey, I want the latest version, as long as it's not higher than two.
Cool.
So now let's run that program again.
It breaks, right?
So chalk has color is not a function.
Sad.
Okay, well, let's go back to the docs.
So they did tell us that.
So let's kind of like simulate that we're in the real world.
We heard there's true color support.
And we're like, yes, give me that now.
And so you go and you install that and then you get this error.
So what I would do is I would go and first I'd try to like search up the error real quickly.
If I don't find anything fast, I would go right to the repository and look at the versions and be like, okay, so I've got like two, version two or whatever, I'm gonna immediately go to where the breaking change happened.
Because that's where the break should be.
Not promising it always is.
But it's where it should be.
And it's the fastest place to look.
And then here, you know, if they're nice, they listed it out.
Oh, cool.
Use the has ANSI package directly instead.
I love it.
Okay, so I'll click that they even give us a link.
How cool are they?
And when you come into here, there's this package and I'll be like, all right, well, I guess it looks like I can just call this now.
So let's try it.
So I'm going to do npm install has ANSI.
I'm going to go over to my code.
And I'm going to import that.
So const has ANSI equals require has ANSI.
And then I'm going to switch out this chalk has color because that's the thing that's broken for just has ANSI and see if it works.
This is really how I develop things.
Sorry if it's disappointing to you, but that's my mood.
Okay, that didn't work.
Unfortunately, must use import to load an ES module.
Oh, that's really unfortunate.
So we're using CJS right now.
And they have this as import.
So it looks like their current version is actually only supporting ES modules, which leads you down in a whole nother rabbit hole.
So let's see what version that we got installed for them.
Let's do a real world thing here.
So npm ls, we have 500.
Okay, so let's go to their versions and see, okay, require nodejs 12.
This package is now pure ESM.
Wow, we got lucky there, right?
So maybe if we go back to four, we'll be fine.
Right?
So let's do this.
npm i has ANSI at and then I'll let it be anything for so for 00.
Four and up is fine with me.
npm ls.
Yeah, we're good.
Let's try it now.
And it worked.
Look at that.
That was real world.
That wasn't planned.
But pretty cool.
So you can kind of see that in action.
It's like, oh, well, things are crazy.
And obviously, I had a little bit of knowledge about the ES modules thing.
So I kind of knew where to look.
But the point is that I can look at what version that I'm at currently with this npm ls, I can be like, Oh, I've got 50.
Let's see what the breaking changes and that will lead you down the you know, trail of breadcrumbs to find what your problem is.
It works for me a lot of times.
Sometimes it doesn't.
But you know, you got to have a lot of tools in your belt to solve these kind of problems.
So this fixed our problem.
And that shows a breaking change that you know, we wanted a new feature.
Let's actually add that new feature real quick because you know, what's the point of doing the bump?
Let me show you this.
So I'm going to do an extra thing here.
And I'm doing some crazy stuff.
But really, what I'm trying to show here is that they have this like level that they added for different levels of color support.
So in this case, it's like no colors.
This is 16 colors, which is what they had before this version two oh, and then this is 256 color support, which is kind of common.
And this is true support true color support, which is like 16 million.
It's some crazy stuff.
Now you're going to see the actual difference because notice that I'm logging the exact same color in all of them.
Just to kind of show this, watch this is cool.
Check this out.
So this is true color, right?
This is the actual color if we were to like hex it and you know, take that color and put it in the other browser.
That's what it would look like.
But you can see that it kind of like tries to pick the nearest one that it supports when it's only 256 colors.
And then when it's 16 colors, it's not really even close, unfortunately.
So this is the strides that they've made just to kind of showcase that this is the new feature that we wanted.
So we wanted this feature and we had to install a breaking change to get it and then it broke our code.
And so we had to go and look and see, okay, at least they documented that has colors not supported anymore.
How can I find that out?
And they were nice enough to give us a link to that has color package or has ANSI package.
That's what it is.
So now you've seen a breaking change.
That's a simple node version bump, which is really, really common and also a breaking change, which is a code change.
Now, as you've been seeing all of this, I hope that in the back of your mind, you're kind of starting to see how to actually develop software in a cool way.
Like notice how nice it was for us to know and be notified that, hey, when you want to get this feature, you're going to actually have some breaking changes.
Make sure that you check and see if you have to update your code.
Sometimes you won't.
And a lot of times you will, but they should have some documentation around that.
And so now when you're developing software throughout your career, I hope you'll think about that pattern.
There are other patterns out there, of course, but this is at least a nice one that has some sort of structure that says, when you write code, when you make a change, you have to think about your users.
Am I going to break their stuff?
I probably shouldn't do that right away.
You know, let's make this a patch if we can.
Let's make this a minor if it's a new feature and not put any breaking changes.
Or if we really have to, if we feel like it's just too much work for us or we want some new functionality or whatever it is, there's a lot of reasons for it, we'll make a breaking change, but at least they'll know that it's that and we should document it.
We should be the cool developers that let them know, hey, if you want this new feature, just so you know, you might run in these things, we broke these things.
It is a breaking change, which means that your code might have to update or you need a new node version or something like that.
Really, this just helps you become a better, more robust software developer by just learning how this thing works, semantic versioning, and incorporating that in how you write code, especially if other people are using your code and consuming packages and all that.
But even if you're not using packages, I think it's a still a good way to deliver code in general.
You know, you can document it however you want.
But the point is, you selectively always think when you make code updates that anyone's going to use, you know, what kind of changes this?
Is it just a little bug fix?
Is it a new feature?
Or does it actually break some existing code if people use it, and we should notify them?
I believe that will sum up this video.
I hope that this practical example of some larger used packages that, you know, are used by tons and tons of developers every day was a useful tool in seeing exactly how they distribute their packages and how you can go about troubleshooting breaking changes when you encounter them.
But maybe even more importantly, while you're here, you get the gist of semantic versioning and what those little numbers mean, and the couple little special symbols in front of them.
Thanks for watching, and I hope to see you in the next one.